# Progression - 2026-01-18 01:40

## Session: Classification de domaine par fichier + corrections

---

## Objectif principal

Implémenter la classification de domaine **par fichier** (et non par node) pour l'extraction d'entités GLiNER.

---

## Travail accompli

### 1. Endpoint `/classify/batch` (Python)

**Fichier**: `services/gliner_service/main.py`

Ajouté endpoint pour classifier plusieurs textes en batch:
```python
@app.post("/classify/batch")
async def classify_domains_batch(texts: list[str], threshold: float = 0.3, batch_size: int = 64)
```

Utilise `extractor.classify_domains_batch()` qui existait déjà dans `extractor.py`.

---

### 2. Client TypeScript

**Fichier**: `src/ingestion/entity-extraction/client.ts`

Ajouté:
- `classifyDomainsBatch(texts, threshold, batchSize)` - classification batch
- `extractBatchWithDomains(texts, domains, batchSize)` - extraction avec domaines multiples fusionnés

```typescript
// Classification batch de fichiers
const classifications = await client.classifyDomainsBatch(fileContents, 0.3);

// Extraction avec domaines fusionnés (ex: ["legal", "tech"])
const results = await client.extractBatchWithDomains(texts, ["legal", "tech"]);
```

---

### 3. UnifiedProcessor - Classification par fichier

**Fichier**: `src/ingestion/unified-processor.ts`

Modifié `processLinked()` pour:

#### Phase 1: Classification des fichiers
```typescript
// Lire le contenu de chaque fichier (2000 chars pour classification)
const fileContents = await Promise.all(filePaths.map(f => fs.readFile(f, 'utf-8')));

// Classification batch
const classifications = await this.entityClient.classifyDomainsBatch(fileContents, 0.3);

// Créer combo key trié: "legal|tech"
const comboKey = domainLabels.sort().join('|');
```

#### Phase 2: Groupement par combo de domaines
```typescript
const nodesByDomainCombo = new Map<string, Node[]>();
// Fichiers avec même combo sont groupés ensemble
```

#### Phase 3: Extraction par groupe
```typescript
for (const [comboKey, nodes] of nodesByDomainCombo) {
  const domains = comboKey.split('|'); // ["legal", "tech"]
  await this.extractEntitiesGlobalBatchWithDomains(nodes, domains);
}
```

Ajouté méthode `extractEntitiesGlobalBatchWithDomains()` qui fusionne les entity_types de plusieurs domaines.

---

### 4. Fix: Boucle infinie sur Entity filtrées

**Problème**: Les Entity de type `price`, `date`, `quantity`, etc. étaient filtrées de la génération d'embeddings mais restaient en `_state='linked'` → boucle infinie du ProcessingLoop.

**Solution**: Après génération d'embeddings, marquer ces entities comme `embedded`:

```typescript
// Mark filtered Entity types as 'embedded'
await this.neo4jClient.run(`
  MATCH (e:Entity {projectId: $projectId})
  WHERE e._state = 'linked'
    AND e.entityType IN ['price', 'date', 'quantity', 'amount', 'currency', 'size', 'duration']
  SET e._state = 'embedded'
  RETURN count(e) AS marked
`, { projectId: this.projectId });
```

---

## Architecture finale

```
┌─────────────────────────────────────────────────────────────┐
│                    processLinked()                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Phase 1: Classification des fichiers                       │
│  ─────────────────────────────────────                      │
│  48 fichiers → /classify/batch → domain par fichier         │
│                                                             │
│  Fichier A → ["legal", "tech"]  → combo "legal|tech"        │
│  Fichier B → ["tech"]           → combo "tech"              │
│  Fichier C → ["legal", "tech"]  → combo "legal|tech"        │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Phase 2: Groupement par combo                              │
│  ─────────────────────────────────                          │
│  "legal|tech": [nodes de A, C]                              │
│  "tech":       [nodes de B]                                 │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Phase 3: Extraction par groupe                             │
│  ─────────────────────────────────                          │
│  [legal|tech] → extractBatch avec                           │
│                 legal_entities ∪ tech_entities              │
│                                                             │
│  [tech]       → extractBatch avec                           │
│                 tech_entities                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Fichiers modifiés

| Fichier | Modifications |
|---------|---------------|
| `services/gliner_service/main.py` | Ajout `/classify/batch` |
| `src/ingestion/entity-extraction/client.ts` | Ajout `classifyDomainsBatch()`, `extractBatchWithDomains()` |
| `src/ingestion/unified-processor.ts` | Classification par fichier, groupement par combo, fix boucle infinie |

---

### 5. Centralisation: skip_embedding_types

**Problème**: La liste des types d'entités qui ne doivent pas avoir d'embeddings était dupliquée en 3 endroits:
- `src/ingestion/entity-extraction/deduplication.ts` (EXCLUDED_DEDUP_TYPES)
- `src/ingestion/unified-processor.ts` (requête Cypher hardcodée)
- `src/brain/embedding-service.ts` (requête Cypher hardcodée)

**Solution**: Source unique de vérité dans `entity-extraction.yaml` (config GLiNER).

#### Fichiers modifiés:

| Fichier | Modification |
|---------|--------------|
| `services/gliner_service/entity-extraction.yaml` | Ajout section `skip_embedding_types` |
| `services/gliner_service/config.py` | `get_skip_embedding_types()`, `SKIP_EMBEDDING_TYPES` global |
| `services/gliner_service/models.py` | Ajout `skip_embedding_types` à `ConfigResponse` |
| `services/gliner_service/main.py` | Inclusion dans `/config` endpoint |
| `src/ingestion/entity-extraction/client.ts` | `getSkipEmbeddingTypes()` (async, cached), `DEFAULT_SKIP_EMBEDDING_TYPES` (fallback) |
| `src/ingestion/entity-extraction/deduplication.ts` | Import de `DEFAULT_SKIP_EMBEDDING_TYPES` |
| `src/ingestion/unified-processor.ts` | Utilise `entityClient.getSkipEmbeddingTypes()` |
| `src/brain/embedding-service.ts` | Import de `DEFAULT_SKIP_EMBEDDING_TYPES` |

#### Configuration YAML (source de vérité):

```yaml
# services/gliner_service/entity-extraction.yaml
skip_embedding_types:
  - price
  - date
  - quantity
  - amount
  - currency
  - size
  - duration
```

#### Architecture:

```
                    entity-extraction.yaml
                           │
                           ▼
                    ┌──────────────┐
                    │  config.py   │
                    │  /config API │
                    └──────────────┘
                           │
            ┌──────────────┼──────────────┐
            ▼              ▼              ▼
    client.ts         client.ts      client.ts
    (async fetch)     (DEFAULT_*)    (DEFAULT_*)
         │                │               │
         ▼                ▼               ▼
  unified-processor   deduplication   embedding-service
```

---

### 6. Outil MCP `restart_daemon`

**Problème**: Pas de moyen simple de redémarrer le daemon depuis Claude Code / MCP.

**Solution**: Nouvel outil MCP `restart_daemon` avec option pour contrôler les watchers.

#### Fichiers modifiés:

| Fichier | Modification |
|---------|--------------|
| `src/daemon/daemon-client.ts` | Ajout `restartDaemon()`, `waitForDaemonStop()`, interfaces |
| `src/cli/commands/daemon.ts` | Check env var `RAGFORGE_SKIP_AUTO_WATCHERS` |
| `src/tools/brain-tools.ts` | `generateRestartDaemonTool()`, `generateRestartDaemonHandler()` |

#### API:

```typescript
// daemon-client.ts
export async function restartDaemon(options: {
  withWatchers?: boolean;  // default: true
  verbose?: boolean;       // default: false
}): Promise<RestartDaemonResult>

// MCP tool
restart_daemon()                         // Restart avec watchers (default)
restart_daemon({ with_watchers: false }) // Restart sans watchers
```

#### Comportement:

1. Stop le daemon actuel (si tournant)
2. Attend que le port 6969 soit libéré
3. Démarre un nouveau daemon
4. Si `withWatchers=true` (default), les watchers sont auto-démarrés via `autoStartWatchersForCwd()`
5. Si `withWatchers=false`, env var `RAGFORGE_SKIP_AUTO_WATCHERS=1` est set pour skip les watchers

---

## Prochaines étapes

- [ ] Tester avec ingestion complète
- [x] Implémenter outil MCP `restart_daemon` avec option watchers
- [ ] Optimiser mémoire GPU (voir `docs/gpu-memory-optimization.md`)

---

## Notes

- Le combo de domaines permet de regrouper des fichiers similaires
- Prépare le terrain pour utilisation future de LLM (un appel pour plusieurs nodes du même domaine)
- Les Entity de type numérique (price, date, etc.) n'ont pas besoin d'embeddings
- La config `skip_embedding_types` est maintenant centralisée dans le YAML GLiNER
